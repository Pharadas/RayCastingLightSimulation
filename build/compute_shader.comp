#version 430 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// ----------------------------------------------------------------------------
//
// uniforms
//
// ----------------------------------------------------------------------------

layout(rgba32f, binding = 0) uniform image2D imgOutput;

layout (location = 0) uniform float t;                 /** Time */
layout (location = 1) uniform vec2 viewportDimensions;
layout (location = 3) uniform vec3 position;
layout (location = 4) uniform vec2 rotation;

#define PI 3.141592

#define MAX_REHITS 0

const bool USE_BRANCHLESS_DDA = true;
const int MAX_RAY_STEPS = 200;

#define POLARIZADOR 0
#define RETARDADOR  1

struct RayObject {
  vec3 rayDir;
  vec3 rayPos;
  ivec3 mapPos;

  vec3 deltaDist;
  ivec3 rayStep;
  vec3 sideDist; 

  bvec3 mask;

  float d;
  vec3 dst;
  vec3 originalDir;

  bool endedInHit;

  vec4 color;
};

struct ObjetoOptico {
    int tipo;
    float valor;
};

// Hyperboloc functions by toneburst from 
// https://machinesdontcare.wordpress.com/2008/03/10/glsl-cosh-sinh-tanh/
// These are missing in GLSL 1.10 and 1.20, uncomment if you need them 

/*
// COSH Function (Hyperbolic Cosine)
float cosh(float val)
{
    float tmp = exp(val);
    float cosH = (tmp + 1.0 / tmp) / 2.0;
    return cosH;
}
 
// TANH Function (Hyperbolic Tangent)
float tanh(float val)
{
    float tmp = exp(val);
    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);
    return tanH;
}
 
// SINH Function (Hyperbolic Sine)
float sinh(float val)
{
    float tmp = exp(val);
    float sinH = (tmp - 1.0 / tmp) / 2.0;
    return sinH;
}   
*/

// Complex Number math by julesb
// https://github.com/julesb/glsl-util
// Additions by Johan Karlsson (DonKarlssonSan)

#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))
#define cx_modulus(a) length(a)
#define cx_conj(a) vec2(a.x, -a.y)
#define cx_arg(a) atan(a.y, a.x)
#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))
#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))

vec2 cx_sqrt(vec2 a) {
    float r = length(a);
    float rpart = sqrt(0.5*(r+a.x));
    float ipart = sqrt(0.5*(r-a.x));
    if (a.y < 0.0) ipart = -ipart;
    return vec2(rpart,ipart);
}

vec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }

vec2 cx_log(vec2 a) {
    float rpart = sqrt((a.x*a.x)+(a.y*a.y));
    float ipart = atan(a.y,a.x);
    if (ipart > PI) ipart=ipart-(2.0*PI);
    return vec2(log(rpart),ipart);
}

vec2 cx_mobius(vec2 a) {
    vec2 c1 = a - vec2(1.0,0.0);
    vec2 c2 = a + vec2(1.0,0.0);
    return cx_div(c1, c2);
}

vec2 cx_z_plus_one_over_z(vec2 a) {
    return a + cx_div(vec2(1.0,0.0), a);
}

vec2 cx_z_squared_plus_c(vec2 z, vec2 c) {
    return cx_mul(z, z) + c;
}

vec2 cx_sin_of_one_over_z(vec2 z) {
    return cx_sin(cx_div(vec2(1.0,0.0), z));
}

////////////////////////////////////////////////////////////
// end Complex Number math by julesb
////////////////////////////////////////////////////////////

// My own additions to complex number math
#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)
#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)
#define cx_abs(a) length(a)
vec2 cx_to_polar(vec2 a) {
    float phi = atan(a.y / a.x);
    float r = length(a);
    return vec2(r, phi); 
}
    
// Complex power
// Let z = r(cos θ + i sin θ)
// Then z^n = r^n (cos nθ + i sin nθ)
vec2 cx_pow(vec2 a, float n) {
    float angle = atan(a.y, a.x);
    float r = length(a);
    float real = pow(r, n) * cos(n*angle);
    float im = pow(r, n) * sin(n*angle);
    return vec2(real, im);
}

vec2 cx_exp(vec2 a) {
    float angle = atan(a.y, a.x);
    return vec2(cos(angle), sin(angle));
}

float computeDistance(vec3 A, vec3 B, vec3 C) {
	float x = length(cross(B - A, C - A));
	float y = length(B - A);
	return x / y;
}

bool getVoxel(ivec3 c) {
	// return abs(c.x) > 20 || abs(c.y) > 20 || abs(c.z) > 20 || c == ivec3(5, 5, 5) || c == ivec3(5, 5, 6) || ((abs(c.x) < 2) && (c.z == 5) && false) || c == ivec3(2, 0, 0) || c == ivec3(-2, 0, 0);
	return abs(c.x) > 20 || abs(c.y) > 20 || abs(c.z) > 20 || c.xy == ivec2(5, 5); // || c == ivec3(4, 12, 5) || c == ivec3(-4, -1, 9);
}

float checker(vec3 p) {
    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));
}

vec3 rotate3dZ(vec3 v, float a) {
    float cosA = cos(a);
    float sinA = sin(a);
    return vec3(
        v.x * cosA - v.y * sinA,
        v.x * sinA + v.y * cosA,
        v.z);
}

vec3 rotate3D(vec3 v, vec2 rotation) {
    float cos_a_x = cos(rotation.y);
    float sin_a_x = sin(rotation.y);

    float cos_a_y = cos(rotation.x);
    float sin_a_y = sin(rotation.x);

    vec3 temp_vec = vec3(
        v.x,
        v.y * cos_a_x - v.z * sin_a_x,
        v.y * sin_a_x + v.z * cos_a_x
    );

    return vec3(
        temp_vec.x * cos_a_y + temp_vec.z * sin_a_y,
        temp_vec.y,
        -temp_vec.x * sin_a_y + temp_vec.z * cos_a_y
    );
}

vec3 rotate3dY(vec3 v, float a) {
    float cosA = cos(a);
    float sinA = sin(a);
    return vec3(
        v.x * cosA + v.z * sinA,
        v.y,
        -v.x * sinA + v.z * cosA
    );
}

vec3 rotate3dX(vec3 v, float a) {
    float cosA = cos(a);
    float sinA = sin(a);
    return vec3(
        v.x,
        v.y * cosA - v.z * sinA,
        v.y * sinA + v.z * cosA
    );
}

vec2 rotate2d(vec2 v, float a) {
	float sinA = sin(a);
	float cosA = cos(a);
	return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);	
}

void setup_ray_direction(inout RayObject ray) {
  ray.deltaDist = 1.0 / abs(ray.rayDir);
  ray.rayStep = ivec3(sign(ray.rayDir));
  ray.sideDist = (sign(ray.rayDir) * (vec3(ray.mapPos) - ray.rayPos) + (sign(ray.rayDir) * 0.5) + 0.5) * ray.deltaDist; 
}

void step_ray(inout RayObject ray) {
  ray.mask = lessThanEqual(ray.sideDist.xyz, min(ray.sideDist.yzx, ray.sideDist.zxy));
  ray.sideDist += vec3(ray.mask) * ray.deltaDist;
  ray.mapPos += ivec3(vec3(ray.mask)) * ray.rayStep;
}

bool travel_to_point(inout RayObject ray) {
	for (int i = 0; i < MAX_RAY_STEPS; i++) {
    step_ray(ray);
    if (getVoxel(ray.mapPos)) {
			ray.d = length(vec3(ray.mask) * (ray.sideDist - ray.deltaDist));
			ray.dst = ray.rayPos + ray.rayDir * ray.d; 

			// float t = 0.5 + 0.5 * checker(dst);
			// float t = .2 + checker(ray.dst);
			// ray.color *= vec4(t, t, t, 1);
			// vec4 attenuation_value = vec4(1 / pow(float(hits), 10));
			vec4 attenuation_value = vec4(1);

			if (ray.mask.x) {
				// ray.color *= vec4(1.) - (vec4(0.8, 0.1, 0.1, 1.0) * attenuation_value);
				ray.color *= (vec4(0.8, 0.1, 0.1, 1.0) * attenuation_value);
			}

			if (ray.mask.y) {
				ray.color *= (vec4(0.1, 0.1, 0.8, 1.0) * attenuation_value);
			}

			if (ray.mask.z) {
				ray.color *= (vec4(0.1, 0.8, 0.1, 1.) * attenuation_value);
			}

      // ray.rayDir = reflect(ray.rayDir, vec3(ray.mask));
      // setup_ray_direction(ray);

      return false;
    } else if (ray.mapPos == ivec3(0, 0, 0)) {
      return true;
    }
  }

		// 	// checamos si esta expuesto a la luz
		// 	int m = 0;
		// 	float w0 = 0.1;
		//
		// 	vec3 newRayPos = dst;
		// 	vec3 newRayDir = normalize(lightPosition - newRayPos);
		//
		// 	vec3 newDeltaDist = abs(vec3(length(newRayDir)) / newRayDir);
		// 	ivec3 newRayStep = ivec3(sign(newRayDir));
		// 	vec3 newSideDist = (sign(newRayDir) * (vec3(mapPos) - newRayPos) + (sign(newRayDir) * 0.5) + 0.5) * newDeltaDist;
		// 	bvec3 newMask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)); 
		// 	ivec3 newMapPos = mapPos;
		// 	vec3 newDst = dst;
		//
  //     int contadorDeObjetosOpticosEncontrados = 0;
  //     ObjetoOptico[] objetosOpticosEncontrados = {
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //         {0, 0.0},
  //     };
		//
		// 	float newD = d;
		//
		// 	if (dot(mapPos - lightPosition, vec3(mask) * -rayStep) < 0) {
		// 		ray.color *= vec4(0.05);
		// 		break;
		// 	}
		//
		// 	for (int r = 0; r < MAX_RAY_STEPS; r++) {
		// 		// newMask = lessThanEqual(newSideDist.xyz, min(newSideDist.yzx, newSideDist.zxy));
		// 		//
		// 		// newSideDist += vec3(newMask) * newDeltaDist;
		// 		// newMapPos += ivec3(vec3(newMask)) * newRayStep;
		// 		//
		// 		// newD = length(vec3(newMask) * (newSideDist - newDeltaDist));
		// 		// newDst = newRayPos + newRayDir * newD; 
		// 		//
		// 		// newSideDist = (sign(newRayDir) * (vec3(newMapPos) - newRayPos) + (sign(newRayDir) * 0.5) + 0.5) * newDeltaDist;
		// 		//
		// 		// if (newMapPos == ivec3(-1000, -1000, -1000)) { // chocamos con un polarizador
  //   //       // voy a usar la posicion del polarizador para crear su angulo, solo para poder ver
  //   //       // el efecto de varios sobre un mismo haz
  //   //       objetosOpticosEncontrados[contadorDeObjetosOpticosEncontrados] = ObjetoOptico(POLARIZADOR, PI / (newMapPos.y - 3));
  //   //       contadorDeObjetosOpticosEncontrados++;
		// 		//
		// 		// } else if (newMapPos == ivec3(0, 0, 3)) {
  //   //       objetosOpticosEncontrados[contadorDeObjetosOpticosEncontrados] = ObjetoOptico(RETARDADOR, PI / 4);
  //   //       contadorDeObjetosOpticosEncontrados++;
		// 		//
  //   //     } else if (newMapPos == ivec3(lightPosition)) {
  //   //       for (int indiceDeObjetoOpticoEncontrado = contadorDeObjetosOpticosEncontrados - 1; indiceDeObjetoOpticoEncontrado >= 0; indiceDeObjetoOpticoEncontrado--) {
  //   //         if (objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].tipo == POLARIZADOR) {
  //   //           color *= pow(cos(anguloActualDePolarizacion - objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].valor), 2);
  //   //           anguloActualDePolarizacion = objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].valor;
		// 		//
  //   //         } else if (objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].tipo == RETARDADOR) {
  //   //             // implementacion
  //   //         }
  //   //     }
		// 		//
  //   //     // float intensityx = computeDistance(lightPosition, position, newDst);
  //   //     // float intensityy = computeDistance(lightPosition, lightPosition + rotate3D(lightPosition - position, vec2(PI / 2, PI / 2)), newDst);
		// 		//
  //   //     // float intensity = intensityx < intensityy ? intensityx : intensityy;
  //   //     // float intensity = computeDistance(lightPosition, position, newDst);
  //   //     float intensity = 0.01;
		// 		//
  //   //     vec2 result = cx_exp(vec2(0, m * 90));
  //   //     color *= vec4(1.0, 0.1, 0.1, 1.0) * cx_abs(cx_mul(vec2(pow(intensity / w0, m) * exp(-pow(intensity, 2) / pow(w0, 2)), 0), result));
		// 		//
  //   //     // color *= vec4(1.0, 0.1, 0.1, 1.0);
  //   //     r = MAX_RAY_STEPS + 1;
		// 		//
		// 		// } else if (getVoxel(newMapPos)) {
		// 		// 	color *= vec4(0.0);
		// 		// 	r = MAX_RAY_STEPS + 1;
		// 		// }
		// 	}

		// mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
		//
		// sideDist += vec3(mask) * deltaDist;
		// mapPos += ivec3(vec3(mask)) * rayStep;
		//
		// d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized
		// dst = rayPos + rayDir * d; 
		//
		// #ifdef BLACK_HOLE
  //     vec3 newDir = blackHolePosition - dst;
		//
  //     float force = - -.1 / pow(length(newDir), 3);
		//
  //     if (dot(newDir * force, rayDir) > 0.1) {
  //       color = vec4(0.);
  //       break;
  //     }
		//
  //     rayDir = normalize(rayDir + (newDir * force));
  //   #endif

    // deltaDist = abs(vec3(length(rayDir)) / rayDir);
    // rayStep = ivec3(sign(rayDir));
    // sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
}

void main() {
  vec4 color = vec4(1.);
  float anguloActualDePolarizacion = mod(t * 0.5, PI);

  ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

  float width = 1000;

  vec4 fragCoord = vec4(texelCoord, 0.0, 1.0);
  vec2 screenPos = (fragCoord.xy / viewportDimensions.xy) * 2.0 - 1.0;
  vec3 cameraDir = vec3(0.0, 0.0, 0.8);
  vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);
  vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * viewportDimensions.y / viewportDimensions.x;
  vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;
  vec3 rayPos = position;
  vec3 realPos = position;

  rayDir = rotate3dX(rayDir, rotation.y);
  rayDir = rotate3dY(rayDir, rotation.x);

  rayDir = normalize(rayDir);

  int hits = 0;

	// vec3 lightPosition = vec3(0.5, 0.5, 0.5);
  float r = 3.;

  float theta_rot = 0;
  float phi_rot = 0;
  float r_dist = 10000;

  ivec3 mapPos = ivec3(floor(rayPos + 0.));

  vec3 deltaDist = 1.0 / abs(rayDir);
  ivec3 rayStep = ivec3(sign(rayDir));
  vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 

  vec3 lastDeltaDist;
  ivec3 lastRayStep;
  ivec3 lastMapPos;
  vec3 lastSideDist;
  bvec3 lastMask;

  vec3 lastHitPosition;

  bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

  float d;
  d = length(vec3(mask) * (sideDist - deltaDist));
  vec3 dst = rayPos + rayDir * d;

//  RayObject rayo;
//  rayo.rayDir = rayDir;
//  rayo.rayPos = rayPos;
//  rayo.mapPos = mapPos;
//  rayo.deltaDist = deltaDist;
//  rayo.rayStep = rayStep;
//  rayo.sideDist = sideDist;
//  rayo.mask = mask;
//  rayo.color = vec4(1.0);
//  rayo.d = d;
//  rayo.dst = dst;
//
//  travel_to_point(rayo);
//
//  vec4 color_original = rayo.color;
//
//  if (dot(rayo.dst - lightPosition, vec3(rayo.mask) * -rayo.rayStep) > 0.) {
//    rayo.color *= vec4(0.05);
//  } else {
//    rayo.rayPos = rayo.dst;
//    rayo.rayDir = normalize(lightPosition - rayo.rayPos);
//    setup_ray_direction(rayo);
//
//    rayo.rayStep = ivec3(sign(rayo.rayDir));
//
//    if (!travel_to_point(rayo)) {
//      rayo.color *= vec4(0.05);
//    }
//  }
//
//  rayo.mask = lessThanEqual(rayo.sideDist.xyz, min(rayo.sideDist.yzx, rayo.sideDist.zxy)); 
//  step_ray(rayo);

      // if (!travel_to_point(rayo)) {
      //    rayo.color *= vec4(0.5, 0.5, 0.5, 1.);
      // }

	for (int i = 0; i < MAX_RAY_STEPS; i++) {
		if (getVoxel(mapPos) && i != 0) {
			hits++;
			// lastRayPos = rayPos;

			d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized
			dst = rayPos + rayDir * d; 

			// float t = 0.5 + 0.5 * checker(dst);
            float h = .2 + checker(dst);
			// float t = .2 + checker(dst);
			color *= vec4(h, h, h, 1);
			vec4 attenuation_value = vec4(1 / pow(float(hits), 10));

			if (mask.x) {
				color *= (vec4(0.8, 0.1, 0.1, 1.0) * attenuation_value);
			}

			if (mask.y) {
				color *= (vec4(0.1, 0.1, 0.8, 1.0) * attenuation_value);
			}

			if (mask.z) {
				color *= (vec4(0.1, 0.8, 0.1, 1.) * attenuation_value);
			}

			rayDir = reflect(rayDir, vec3(mask));

			deltaDist = abs(vec3(length(rayDir)) / rayDir);
			rayStep = ivec3(sign(rayDir));
			sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;

			// checamos si esta expuesto a la luz
			int m = 2;
			float w0 = 0.1;

      float[] total_intensity = {0., 0.};
      float[] total_phase = {0., 0.};
      vec3[2] dists;

      for (int f = 0; f < 2; f++) {
        vec4 newColor = vec4(1.);
        vec3 lightPosition;

        if (f == 0) {
          lightPosition = vec3(0.5, 0.5, 0.5);
        } else {
          lightPosition = vec3(0.5, 0.5, 0.5);
        }

        vec3 newRayPos = dst;
        vec3 newRayDir = normalize(lightPosition - newRayPos);

        vec3 newDeltaDist = abs(vec3(length(newRayDir)) / newRayDir);
        ivec3 newRayStep = ivec3(sign(newRayDir));
        vec3 newSideDist = (sign(newRayDir) * (vec3(mapPos) - newRayPos) + (sign(newRayDir) * 0.5) + 0.5) * newDeltaDist;
        bvec3 newMask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        ivec3 newMapPos = mapPos;
        vec3 newDst = dst;

        int contadorDeObjetosOpticosEncontrados = 0;
        ObjetoOptico[] objetosOpticosEncontrados = {
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
            {0, 0.0},
        };

        float newD = d;

        if (dot(mapPos - lightPosition, vec3(mask) * -rayStep) < 0) {
          newColor *= vec4(0.05);
          break;
        }

        vec4 tempColor = vec4(0.);

        for (int r = 0; r < MAX_RAY_STEPS; r++) {
          newMask = lessThanEqual(newSideDist.xyz, min(newSideDist.yzx, newSideDist.zxy));

          newSideDist += vec3(newMask) * newDeltaDist;
          newMapPos += ivec3(vec3(newMask)) * newRayStep;

          newD = length(vec3(newMask) * (newSideDist - newDeltaDist));
          newDst = newRayPos + newRayDir * newD; 

          newSideDist = (sign(newRayDir) * (vec3(newMapPos) - newRayPos) + (sign(newRayDir) * 0.5) + 0.5) * newDeltaDist;

          if (newMapPos == ivec3(-1000, -1000, -1000)) { // chocamos con un polarizador
            // voy a usar la posicion del polarizador para crear su angulo, solo para poder ver
            // el efecto de varios sobre un mismo haz
            objetosOpticosEncontrados[contadorDeObjetosOpticosEncontrados] = ObjetoOptico(POLARIZADOR, PI / (newMapPos.y - 3));
            contadorDeObjetosOpticosEncontrados++;

          } else if (newMapPos == ivec3(0, 0, 3)) {
            objetosOpticosEncontrados[contadorDeObjetosOpticosEncontrados] = ObjetoOptico(RETARDADOR, PI / 4);
            contadorDeObjetosOpticosEncontrados++;

          } else if (newMapPos == ivec3(lightPosition)) {
            for (int indiceDeObjetoOpticoEncontrado = contadorDeObjetosOpticosEncontrados - 1; indiceDeObjetoOpticoEncontrado >= 0; indiceDeObjetoOpticoEncontrado--) {
            if (objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].tipo == POLARIZADOR) {
              newColor *= pow(cos(anguloActualDePolarizacion - objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].valor), 2);
              anguloActualDePolarizacion = objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].valor;

            } else if (objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].tipo == RETARDADOR) {
                // implementacion
            }
          }

          // float intensityx = computeDistance(lightPosition, position, newDst);
          // float intensityy = computeDistance(lightPosition, lightPosition + rotate3D(lightPosition - position, vec2(PI / 2, PI / 2)), newDst);

          // float intensity = intensityx < intensityy ? intensityx : intensityy;
          float intensity;
          if (f == 0) {
            intensity = computeDistance(lightPosition, position, newDst);
            total_phase[f] += cos(0.1 * length(lightPosition - newDst) + t * 0.5) * 100;
          } else {
            intensity = sqrt(pow(lightPosition.x - newDst.x, 2) + pow(lightPosition.y - newDst.y, 2));
            total_phase[f] += cos(0.1 * length(lightPosition - newDst)) * 100;
          }
          // float intensity = 0.01;

          vec2 result = cx_exp(vec2(0, m * 90));
          newColor *= vec4(1.0, 0.1, 0.1, 1.0) * cx_abs(cx_mul(vec2(pow(intensity / w0, m) * exp(-pow(intensity, 2) / pow(w0, 2)), 0), result));
          total_intensity[f] = cx_abs(cx_mul(vec2(pow(intensity / w0, m) * exp(-pow(intensity, 2) / pow(w0, 2)), 0), result));
          total_phase[f] *= total_intensity[f];

          dists[f] = abs(dst - lightPosition);

          // color *= vec4(1.0, 0.1, 0.1, 1.0);
          r = MAX_RAY_STEPS + 1;

          } else if (getVoxel(newMapPos)) {
            newColor *= vec4(0.5);
            r = MAX_RAY_STEPS + 1;
          }
        }
      }

      // just define how the polarizers will look for now
      vec2[] polarizationFirst =  {vec2(0.5, 0), vec2(0.5, 0)};
      vec2[] polarizationSecond = {vec2(0.5, 0), vec2(0.5, 0)};

      float f = 0.5;

      vec2[] polFirst = {
        cx_mul(cx_exp(cx_mul(vec2(f, 0), vec2(0, -1))), polarizationFirst[0]),
        cx_mul(cx_exp(cx_mul(vec2(f, 0), vec2(0, -1))), polarizationFirst[1])
      };

      vec2[] polSecond = {
        cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(f, 0))), polarizationSecond[0]),
        cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(f, 0))), polarizationSecond[1])
      };

      // vec2 resultingPolarizationFirstX = cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(dists[0], 0))), vec2(1, 0));
      // vec2 resultingPolarizationFirstY = cx_mul(cx_exp(cx_mul(vec2(0, 1), vec2(dists[0], 0))), vec2(1, 0));

      // vec2 resultingPolarizationFirstX = cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(w0 * dists[0]))), vec2(1, 0));
      // vec2 resultingPolarizationSecondX = cx_mul(cx_exp(cx_mul(vec2(0, 1), vec2(w0 * dists[1]))), vec2(1, 0));

      // vec2 resultingPolarizationFirstY = cx_mul(cx_exp(cx_mul(vec2(0, 1), vec2(w0 * dists[0]))), vec2(1, 0));
      // vec2 resultingPolarizationSecondY = cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(w0 * dists[1]))), vec2(1, 0));

      color *= (4 * total_intensity[0] * pow(cos(abs(total_phase[0] - total_phase[1]) / 2), 2)) + (4 * total_intensity[1] * pow(cos(abs(total_phase[0] - total_phase[1]) / 2), 2));
      // color *= (total_intensity[0] * abs(total_phase[0] + total_phase[1])) + (total_intensity[1] * abs(total_phase[1] + total_phase[0]));

      // color *= abs(total_phase[0] + total_phase[1]);

      // color *= total_phase[0] + total_phase[2]
      // color *= 4 * total_intensity * pow(cos(total_phase / 2), 2);

      // vec2 r = cx_exp(cx_mul(vec2(1, 0), vec2(0, -1)));
      // if (r + 0.1 > 0.8775825618903728 && r - 0.1 < 0.8775825618903728) {
        // color = vec4(abs(cx_mul(vec2(f, 0), vec2(0, -1))).y, 0, 0, 1);
        // color = vec4(0.4 / cx_mul(vec2(f, 0), vec2(0, -1)).x, 0, 0, 1);

        // color *= length(vec2(polFirst[0].x, polFirst[1].x));
        // color *= float(cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(0.1, 0))), vec2(1, 0)).x);

        // color *= clamp(sqrt(
        //  pow(polFirst[0].x + polSecond[0].x, 2) +
        //  pow(polFirst[1].x + polSecond[1].x, 2)
        //), 0, 1);

        // color *= (length(vec2(cx_add(polFirst[0], polSecond[0]).x, cx_add(polFirst[1], polSecond[1]).x)));
        // color *= cx_modulus(cx_add(resultingPolarizationFirstX, resultingPolarizationSecondX) + cx_add(resultingPolarizationSecondX, resultingPolarizationSecondY));
        // color *= cx_modulus(cx_add(resultingPolarizationFirstX, resultingPolarizationSecondX) + cx_add(resultingPolarizationFirstY, resultingPolarizationSecondY));

          if (hits > MAX_REHITS) {
              // endedInHit = true;
              break;
          };
		}

		mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

		sideDist += vec3(mask) * deltaDist;
		mapPos += ivec3(vec3(mask)) * rayStep;

		d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized
		dst = rayPos + rayDir * d; 

		#ifdef BLACK_HOLE
			vec3 newDir = blackHolePosition - dst;

			float force = - -.1 / pow(length(newDir), 3);

			if (dot(newDir * force, rayDir) > 0.1) {
				color = vec4(0.);
				break;
			}

			rayDir = normalize(rayDir + (newDir * force));
		#endif

		deltaDist = abs(vec3(length(rayDir)) / rayDir);
		rayStep = ivec3(sign(rayDir));
		sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
	}

	// TODO: Primero checar que el lado en el que estemos este expuesto a la luz (algo como if (luz.x > pos.x && mask.x) break;)
	// if (hits == 0) color = vec4(0.);

	// value.x = mod(float(texelCoord.x) + t * speed, width) / (gl_NumWorkGroups.x * gl_WorkGroupSize.x);
	// value.y = float(texelCoord.y)/(gl_NumWorkGroups.y*gl_WorkGroupSize.y);

	imageStore(imgOutput, texelCoord, color);
}
