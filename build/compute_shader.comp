#version 430 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imgOutput;

layout (location = 0) uniform float t;
layout (location = 1) uniform vec2 viewportDimensions;
layout (location = 3) uniform vec3 position;
layout (location = 4) uniform vec2 rotation;

#define PI 3.141592

#define MAX_REHITS 1

const bool USE_BRANCHLESS_DDA = true;
const int MAX_RAY_STEPS = 200;

#define LIGHT 0
#define POLARIZADOR 1
#define RETARDADOR  2
#define WALL 3
#define GOAL 4
#define NONE 5

struct OpticalObject {
    int type;
    float value;
    vec3 alternate_value; // Color in the case of light
    vec3 pos;
};

#define NUMBER_OF_OPTICAL_OBJECTS 1

#define LIGHT_OBJECTS OpticalObject[](\
 OpticalObject(LIGHT, 0, vec3(1, 0.5, 0.5), vec3(25.5, 25.5, 25.5)),\
 OpticalObject(LIGHT, 0, vec3(0.1, 0.8, 0.1), vec3(25.5, 25.5, 25.5))\
)

#define OPTICAL_OBJECTS_ARRAY OpticalObject[](\
 OpticalObject(LIGHT, 0, vec3(1), vec3(25.5, 25.5, 25.5)),\
 OpticalObject(LIGHT, 0, vec3(1), vec3(25.5, 25.5, 25.5))\
)

struct OpticalObjectStack {
  OpticalObject[10] objects_hit;
  int number_of_objects_hit;
};

struct RayObject {
  vec3 rayDir;
  vec3 rayPos;
  ivec3 mapPos;

  vec3 deltaDist;
  ivec3 rayStep;
  vec3 sideDist; 

  bvec3 mask;

  float distance_traveled;
  vec3 current_real_position;
  vec3 originalDir;

  bool endedInHit;

  vec4 color;

  OpticalObjectStack object_stack;
};

// Hyperboloc functions by toneburst from 
// https://machinesdontcare.wordpress.com/2008/03/10/glsl-cosh-sinh-tanh/
// These are missing in GLSL 1.10 and 1.20, uncomment if you need them 

/*
// COSH Function (Hyperbolic Cosine)
float cosh(float val)
{
    float tmp = exp(val);
    float cosH = (tmp + 1.0 / tmp) / 2.0;
    return cosH;
}
 
// TANH Function (Hyperbolic Tangent)
float tanh(float val)
{
    float tmp = exp(val);
    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);
    return tanH;
}
 
// SINH Function (Hyperbolic Sine)
float sinh(float val)
{
    float tmp = exp(val);
    float sinH = (tmp - 1.0 / tmp) / 2.0;
    return sinH;
}   
*/

// Complex Number math by julesb
// https://github.com/julesb/glsl-util
// Additions by Johan Karlsson (DonKarlssonSan)

#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))
#define cx_modulus(a) length(a)
#define cx_conj(a) vec2(a.x, -a.y)
#define cx_arg(a) atan(a.y, a.x)
#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))
#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))

vec2 cx_sqrt(vec2 a) {
  float r = length(a);
  float rpart = sqrt(0.5*(r+a.x));
  float ipart = sqrt(0.5*(r-a.x));
  if (a.y < 0.0) ipart = -ipart;
  return vec2(rpart,ipart);
}

vec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }

vec2 cx_log(vec2 a) {
    float rpart = sqrt((a.x*a.x)+(a.y*a.y));
    float ipart = atan(a.y,a.x);
    if (ipart > PI) ipart=ipart-(2.0*PI);
    return vec2(log(rpart),ipart);
}

vec2 cx_mobius(vec2 a) {
    vec2 c1 = a - vec2(1.0,0.0);
    vec2 c2 = a + vec2(1.0,0.0);
    return cx_div(c1, c2);
}

vec2 cx_z_plus_one_over_z(vec2 a) {
    return a + cx_div(vec2(1.0,0.0), a);
}

vec2 cx_z_squared_plus_c(vec2 z, vec2 c) {
    return cx_mul(z, z) + c;
}

vec2 cx_sin_of_one_over_z(vec2 z) {
    return cx_sin(cx_div(vec2(1.0,0.0), z));
}

////////////////////////////////////////////////////////////
// end Complex Number math by julesb
////////////////////////////////////////////////////////////

// My own additions to complex number math
#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)
#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)
#define cx_abs(a) length(a)
vec2 cx_to_polar(vec2 a) {
    float phi = atan(a.y / a.x);
    float r = length(a);
    return vec2(r, phi); 
}
    
// Complex power
// Let z = r(cos θ + i sin θ)
// Then z^n = r^n (cos nθ + i sin nθ)
vec2 cx_pow(vec2 a, float n) {
    float angle = atan(a.y, a.x);
    float r = length(a);
    float real = pow(r, n) * cos(n*angle);
    float im = pow(r, n) * sin(n*angle);
    return vec2(real, im);
}

vec2 cx_exp(vec2 a) {
    float angle = atan(a.y, a.x);
    return vec2(cos(angle), sin(angle));
}

float computeDistance(vec3 A, vec3 B, vec3 C) {
	float x = length(cross(B - A, C - A));
	float y = length(B - A);
	return x / y;
}

bool getVoxel(ivec3 c) {
  int t = 50;
  return c.x < 1 || c.y < 1 || c.z < 1 || c.x > t || c.y > t || c.z > t;
	// return abs(c.x) > 20 || abs(c.y) > 20 || abs(c.z) > 20 || c == ivec3(5, 5, 5) || c == ivec3(5, 5, 6) || ((abs(c.x) < 2) && (c.z == 5) && false) || c == ivec3(2, 0, 0) || c == ivec3(-2, 0, 0);
	// return abs(c.x) > 20 || abs(c.y) > 20 || abs(c.z) > 20 || c.xy == ivec2(5, 5); // || c == ivec3(4, 12, 5) || c == ivec3(-4, -1, 9);
}

// Literally just iterate over the whole every possible object
OpticalObject getOpticalObject(vec3 pos) {
  for (int i = 0; i < NUMBER_OF_OPTICAL_OBJECTS; i++) {
    if (ivec3(OPTICAL_OBJECTS_ARRAY[i].pos) == ivec3(pos)) {
      return OPTICAL_OBJECTS_ARRAY[i];
    }
  }

  return OpticalObject(NONE, 0, vec3(0), vec3(0));
}

float checker(vec3 p) {
    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));
}

vec3 rotate3dZ(vec3 v, float a) {
  float cosA = cos(a);
  float sinA = sin(a);
  return vec3(
    v.x * cosA - v.y * sinA,
    v.x * sinA + v.y * cosA,
    v.z
  );
}

float rayleigh_range(float z, float w0, float wavelength) {
  float n = 1.0;
  float Z_r = (PI * w0 * n) / (wavelength);
  return w0 * sqrt(1 + pow(z / Z_r, 2));
}

vec3 rotate3D(vec3 v, vec2 rotation) {
    float cos_a_x = cos(rotation.y);
    float sin_a_x = sin(rotation.y);

    float cos_a_y = cos(rotation.x);
    float sin_a_y = sin(rotation.x);

    vec3 temp_vec = vec3(
        v.x,
        v.y * cos_a_x - v.z * sin_a_x,
        v.y * sin_a_x + v.z * cos_a_x
    );

    return vec3(
        temp_vec.x * cos_a_y + temp_vec.z * sin_a_y,
        temp_vec.y,
        -temp_vec.x * sin_a_y + temp_vec.z * cos_a_y
    );
}

vec3 rotate3dY(vec3 v, float a) {
    float cosA = cos(a);
    float sinA = sin(a);
    return vec3(
        v.x * cosA + v.z * sinA,
        v.y,
        -v.x * sinA + v.z * cosA
    );
}

vec3 rotate3dX(vec3 v, float a) {
    float cosA = cos(a);
    float sinA = sin(a);
    return vec3(
        v.x,
        v.y * cosA - v.z * sinA,
        v.y * sinA + v.z * cosA
    );
}

vec2 rotate2d(vec2 v, float a) {
	float sinA = sin(a);
	float cosA = cos(a);
	return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);	
}

void setup_ray_direction(inout RayObject ray) {
  ray.deltaDist = 1.0 / abs(ray.rayDir);
  ray.rayStep = ivec3(sign(ray.rayDir));
  ray.sideDist = (sign(ray.rayDir) * (vec3(ray.mapPos) - ray.rayPos) + (sign(ray.rayDir) * 0.5) + 0.5) * ray.deltaDist; 
}

void step_ray(inout RayObject ray) {
  ray.mask = lessThanEqual(ray.sideDist.xyz, min(ray.sideDist.yzx, ray.sideDist.zxy));
  ray.sideDist += vec3(ray.mask) * ray.deltaDist;
  ray.mapPos += ivec3(vec3(ray.mask)) * ray.rayStep;
}

void append_to_object_stack(inout OpticalObjectStack object_stack, OpticalObject object) {
  if (object_stack.number_of_objects_hit < 10) {
    object_stack.objects_hit[object_stack.number_of_objects_hit] = object;
    object_stack.number_of_objects_hit++;
  }
}

// Steps the ray object until it hits an object
// WILL MODIFY THE RAY OBJECT
OpticalObject travel_to_point(inout RayObject ray, bool should_stop_at_goal, vec3 goal) {
  for (int i = 0; i < MAX_RAY_STEPS; i++) {
    step_ray(ray);

    OpticalObject object_hit = getOpticalObject(ray.mapPos);

    if (!should_stop_at_goal && object_hit.type == LIGHT) {
      ray.distance_traveled = length(vec3(ray.mask) * (ray.sideDist - ray.deltaDist));
      ray.current_real_position = ray.rayPos + ray.rayDir * ray.distance_traveled;
      return object_hit;
    }

    if (should_stop_at_goal && ivec3(ray.mapPos) == ivec3(goal)) {
      ray.distance_traveled = length(vec3(ray.mask) * (ray.sideDist - ray.deltaDist));
      ray.current_real_position = ray.rayPos + ray.rayDir * ray.distance_traveled;
      return OpticalObject(GOAL, 0, vec3(0), goal);
    }

    if (object_hit.type != NONE) {
      ray.distance_traveled = length(vec3(ray.mask) * (ray.sideDist - ray.deltaDist));
      ray.current_real_position = ray.rayPos + ray.rayDir * ray.distance_traveled;
      append_to_object_stack(ray.object_stack, object_hit);
    }

    if (getVoxel(ray.mapPos)) {
      ray.distance_traveled = length(vec3(ray.mask) * (ray.sideDist - ray.deltaDist));
      ray.current_real_position = ray.rayPos + ray.rayDir * ray.distance_traveled;

      // float t = 0.5 + 0.5 * checker(dst);
      float h = .2 + checker(ray.current_real_position);
      // ray.color *= vec4(h, h, h, 1);

      // vec4 attenuation_value = vec4(1 / pow(float(hits), 10));
      vec4 attenuation_value = vec4(1);

      if (ray.mask.x) {
          ray.color *= (vec4(0.8, 0.1, 0.1, 1.0) * attenuation_value);
      }

      if (ray.mask.y) {
          ray.color *= (vec4(0.1, 0.1, 0.8, 1.0) * attenuation_value);
      }

      if (ray.mask.z) {
          ray.color *= (vec4(0.1, 0.8, 0.1, 1.) * attenuation_value);
      }

      // ray.rayDir = reflect(ray.rayDir, vec3(ray.mask));
      // setup_ray_direction(ray);

      return OpticalObject(WALL, 0, vec3(0, 0, 0), ray.current_real_position);
    }
  }

  return OpticalObject(NONE, 0, vec3(0, 0, 0), ray.current_real_position);
}

void main() {
  vec4 color = vec4(1.);
  float anguloActualDePolarizacion = mod(t * 0.5, PI);

  ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

  float width = 1000;

  vec4 fragCoord = vec4(texelCoord, 0.0, 1.0);
  vec2 screenPos = (fragCoord.xy / viewportDimensions.xy) * 2.0 - 1.0;
  vec3 cameraDir = vec3(0.0, 0.0, 0.8);
  vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);
  vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * viewportDimensions.y / viewportDimensions.x;
  vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;
  vec3 rayPos = position;
  vec3 realPos = position;

  rayDir = rotate3dX(rayDir, rotation.y);
  rayDir = rotate3dY(rayDir, rotation.x);

  rayDir = normalize(rayDir);

  int hits = 0;

  float r = 3.;

  float theta_rot = 0;
  float phi_rot = 0;
  float r_dist = 10000;

  ivec3 mapPos = ivec3(floor(rayPos + 0.));

  vec3 deltaDist = 1.0 / abs(rayDir);
  ivec3 rayStep = ivec3(sign(rayDir));
  vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 

  vec3 lastDeltaDist;
  ivec3 lastRayStep;
  ivec3 lastMapPos;
  vec3 lastSideDist;
  bvec3 lastMask;

  vec3 lastHitPosition;

  bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

  float d;
  d = length(vec3(mask) * (sideDist - deltaDist));
  vec3 dst = rayPos + rayDir * d;

  OpticalObject[10] temp_optical_object_array = {
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0)),
    OpticalObject(NONE, 0, vec3(0), vec3(0))
  };

  RayObject ray;
    ray.object_stack.objects_hit = temp_optical_object_array;
    ray.object_stack.number_of_objects_hit = 0;
    ray.rayDir = rayDir;
    ray.rayPos = rayPos;
    ray.mapPos = mapPos;
    ray.deltaDist = deltaDist;
    ray.rayStep = rayStep;
    ray.sideDist = sideDist;
    ray.mask = mask;
    ray.color = vec4(1.0);
    ray.distance_traveled = d;
    ray.current_real_position = dst;

  // Hit any wall from the starting POV
  // TODO handle NONE return type
  OpticalObject object_hit = travel_to_point(ray, false, vec3(0));
  float[NUMBER_OF_OPTICAL_OBJECTS] total_intensities = {-1};
  float[NUMBER_OF_OPTICAL_OBJECTS] total_phases = {-1};
  float[NUMBER_OF_OPTICAL_OBJECTS] total_distances = {-1};
  bool [NUMBER_OF_OPTICAL_OBJECTS] lights_hit = {false};

  if (object_hit.type == LIGHT) {
    color = vec4(object_hit.alternate_value, 1);

  } else {
    for (int optical_object_index = 0; optical_object_index < NUMBER_OF_OPTICAL_OBJECTS; optical_object_index++) {
      // First check if we are in a side that's visible by the light
      if (dot(ray.mapPos - LIGHT_OBJECTS[optical_object_index].pos, vec3(ray.mask) * -ray.rayStep) > 0) {
        color *= ray.color * vec4(0.05);

      } else {
        vec3 starting_point = ray.current_real_position;

        // Create a new ray to fire to the light
        RayObject ray_to_light = ray;
          ray_to_light.rayPos = ray_to_light.current_real_position;

          ray_to_light.rayDir = normalize(LIGHT_OBJECTS[optical_object_index].pos - ray_to_light.rayPos);

          ray_to_light.deltaDist = abs(vec3(length(ray_to_light.rayDir)) / ray_to_light.rayDir);
          ray_to_light.rayStep = ivec3(sign(ray_to_light.rayDir));
          ray_to_light.sideDist = (sign(ray_to_light.rayDir) * (vec3(ray_to_light.mapPos) - ray_to_light.rayPos) + (sign(ray_to_light.rayDir) * 0.5) + 0.5) * ray_to_light.deltaDist;
          ray_to_light.mask = lessThanEqual(ray_to_light.sideDist.xyz, min(ray_to_light.sideDist.yzx, ray_to_light.sideDist.zxy));

        // Try to reach a light source
        OpticalObject result = travel_to_point(ray_to_light, true, LIGHT_OBJECTS[optical_object_index].pos);

        // we hit the light source
        if (result.type == GOAL) {
          color *= ray.color * vec4(LIGHT_OBJECTS[optical_object_index].alternate_value, 1);

          int m = 2;
          float w0 = 5;
          float intensity;
          float initial_intensity = 10;
          float f = 5;
          float radius;
          float phase;
          float distance_from_real_light_center = 5;

          // we dont want to simulate a perfectly spherical light because those are boring
          // we will simulate a beam pointing to us, so the distances in the wall will be slightly
          // different and it won't seem like the phase is just a smear on the wall
          vec3 beam_pos = (normalize(position - LIGHT_OBJECTS[optical_object_index].pos) * distance_from_real_light_center) + LIGHT_OBJECTS[optical_object_index].pos;
          float z = length(beam_pos - starting_point);

          if (optical_object_index == 0) {
            z = length(LIGHT_OBJECTS[optical_object_index].pos - starting_point);

            radius = computeDistance(LIGHT_OBJECTS[optical_object_index].pos, vec3(15.5, 25.5, 25.5), starting_point);
            phase = pow(cos(f * z), 1);
            // radius = sqrt(pow(LIGHT_OBJECTS[optical_object_index].pos.x - starting_point.x, 2) + pow(LIGHT_OBJECTS[optical_object_index].pos.y - starting_point.x, 2));
            // phase = pow(cos(f * z + t), 1);
            // phase = PI / 2;

          } else {
            w0 = 1;
            radius = computeDistance(LIGHT_OBJECTS[optical_object_index].pos, position, starting_point);
            // radius = computeDistance(LIGHT_OBJECTS[optical_object_index].pos, vec3(15.5, 25.5, 25.5), starting_point);

            phase = pow(cos(f * z), 1);
            // phase = pow(cos(f * length(LIGHT_OBJECTS[optical_object_index].pos - ray_to_light.current_real_position) + t), 1);
            // phase = PI;
          }

          vec2 result = cx_exp(vec2(0, m * 90));
          float w_z = rayleigh_range(z, w0, 1);
          intensity = initial_intensity * exp((-2 * pow(radius, 2)) / pow(w_z, 2));

          // intensity = initial_intensity * pow(w0 / w_z, 2) * exp(-(2 * pow(radius, 2)) / pow(w_z, 2));
          // ray_to_light.color *= vec4(1.0, 0.1, 0.1, 1.0) * cx_abs(cx_mul(vec2(pow(intensity / w0, m) * exp(-pow(intensity, 2) / pow(w0, 2)), 0), result)) * 10;
          // intensity = cx_abs(cx_mul(vec2(pow(intensity / w0, m) * exp(-pow(intensity, 2) / pow(w0, 2)), 0), result));
          // phase *= intensity;

          total_intensities[optical_object_index] = intensity;
          total_phases[optical_object_index] = phase;
          total_distances[optical_object_index] = z;

          // color *= ray_to_light.color * intensity;

        } else if (result.type == LIGHT) {
          color = vec4(result.alternate_value, 1);

        } else {

          // the ray couldnt hit the light
          color *= ray_to_light.color * vec4(0.1);
        }
      }
    }
  }

  float final_color_intensity = 0;

  for (int i = 0; i < NUMBER_OF_OPTICAL_OBJECTS; i++) {
    // final_color_intensity += total_intensities[i];
    // color *= 
    // color *= (4 * total_intensities[0] * pow(cos(abs(total_phases[0] - total_phases[1]) / 2), 2)) + (4 * total_intensities[1] * pow(cos(abs(total_phases[0] - total_phases[1]) / 2), 2));
  }

  // color *= total_intensities[0] + total_intensities[1];

  // if (total_intensities[0] > 0.1 && total_intensities[1] > 0.1)
  // color *= 2 * (total_intensities[0] + total_intensities[1]) * pow(cos(10 * (total_distances[1] - total_distances[0]) / 2), 2);
  // color *= 2 * (total_intensities[0] + total_intensities[1]) * pow(cos(10 * (total_distances[1] - total_distances[0]) / 2), 2);


  // else
    //color *= total_intensities[0] + total_intensities[1];

  // color *= (total_intensities[0] * pow(cos(abs(total_phases[0] - total_phases[1]) / 2), 2)) + (total_intensities[1] * pow(cos(abs(total_phases[0] - total_phases[1]) / 2), 2));
  // color *= (total_intensities[0] * total_phases[0]) + (total_intensities[1] * total_phases[1]);

  color *= total_intensities[0];

  // color *= final_color_intensity;

  imageStore(imgOutput, texelCoord, color);
}

//for (int i = 0; i < MAX_RAY_STEPS; i++) {
//      if (getVoxel(mapPos) && i != 0) {
//        hits++;
//        // lastRayPos = rayPos;
//
//        d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized
//        dst = rayPos + rayDir * d; 
//
//        // float t = 0.5 + 0.5 * checker(dst);
//        float h = .2 + checker(dst);
//        // float t = .2 + checker(dst);
//        color *= vec4(h, h, h, 1);
//        vec4 attenuation_value = vec4(1 / pow(float(hits), 10));
//
//        if (mask.x) {
//            color *= (vec4(0.8, 0.1, 0.1, 1.0) * attenuation_value);
//        }
//
//        if (mask.y) {
//            color *= (vec4(0.1, 0.1, 0.8, 1.0) * attenuation_value);
//        }
//
//        if (mask.z) {
//            color *= (vec4(0.1, 0.8, 0.1, 1.) * attenuation_value);
//        }
//
//        rayDir = reflect(rayDir, vec3(mask));
//
//        deltaDist = abs(vec3(length(rayDir)) / rayDir);
//        rayStep = ivec3(sign(rayDir));
//        sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
//
//        // checamos si esta expuesto a la luz
//        int m = 2;
//        float w0 = 0.1;
//
//        float[] total_intensity = {0., 0.};
//        float[] total_phase = {0., 0.};
//        vec3[2] dists;
//
//        for (int f = 0; f < 2; f++) {
//          vec4 newColor = vec4(1.);
//          vec3 lightPosition;
//
//          if (f == 0) {
//            lightPosition = vec3(0.5, 0.5, 0.5);
//          } else {
//            lightPosition = vec3(0.5, 0.5, 0.5);
//          }
//
//          vec3 newRayPos = dst;
//          vec3 newRayDir = normalize(lightPosition - newRayPos);
//
//          vec3 newDeltaDist = abs(vec3(length(newRayDir)) / newRayDir);
//          ivec3 newRayStep = ivec3(sign(newRayDir));
//          vec3 newSideDist = (sign(newRayDir) * (vec3(mapPos) - newRayPos) + (sign(newRayDir) * 0.5) + 0.5) * newDeltaDist;
//          bvec3 newMask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
//          ivec3 newMapPos = mapPos;
//          vec3 newDst = dst;
//
//          int contadorDeObjetosOpticosEncontrados = 0;
//          ObjetoOptico[] objetosOpticosEncontrados = {
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//              {0, 0.0},
//          };
//
//    float newD = d;
//
//    if (dot(mapPos - lightPosition, vec3(mask) * -rayStep) < 0) {
//      newColor *= vec4(0.05);
//      break;
//    }
//
//    vec4 tempColor = vec4(0.);
//
//    for (int r = 0; r < MAX_RAY_STEPS; r++) {
//      newMask = lessThanEqual(newSideDist.xyz, min(newSideDist.yzx, newSideDist.zxy));
//
//      newSideDist += vec3(newMask) * newDeltaDist;
//      newMapPos += ivec3(vec3(newMask)) * newRayStep;
//
//      newD = length(vec3(newMask) * (newSideDist - newDeltaDist));
//      newDst = newRayPos + newRayDir * newD; 
//
//      newSideDist = (sign(newRayDir) * (vec3(newMapPos) - newRayPos) + (sign(newRayDir) * 0.5) + 0.5) * newDeltaDist;
//
//      if (newMapPos == ivec3(-1000, -1000, -1000)) { // chocamos con un polarizador
//        // voy a usar la posicion del polarizador para crear su angulo, solo para poder ver
//        // el efecto de varios sobre un mismo haz
//        objetosOpticosEncontrados[contadorDeObjetosOpticosEncontrados] = ObjetoOptico(POLARIZADOR, PI / (newMapPos.y - 3));
//        contadorDeObjetosOpticosEncontrados++;
//
//      } else if (newMapPos == ivec3(0, 0, 3)) {
//        objetosOpticosEncontrados[contadorDeObjetosOpticosEncontrados] = ObjetoOptico(RETARDADOR, PI / 4);
//        contadorDeObjetosOpticosEncontrados++;
//
//      } else if (newMapPos == ivec3(lightPosition)) {
//        for (int indiceDeObjetoOpticoEncontrado = contadorDeObjetosOpticosEncontrados - 1; indiceDeObjetoOpticoEncontrado >= 0; indiceDeObjetoOpticoEncontrado--) {
//        if (objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].tipo == POLARIZADOR) {
//          newColor *= pow(cos(anguloActualDePolarizacion - objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].valor), 2);
//          anguloActualDePolarizacion = objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].valor;
//
//        } else if (objetosOpticosEncontrados[indiceDeObjetoOpticoEncontrado].tipo == RETARDADOR) {
//            // implementacion
//        }
//      }
//
//      // float intensityx = computeDistance(lightPosition, position, newDst);
//      // float intensityy = computeDistance(lightPosition, lightPosition + rotate3D(lightPosition - position, vec2(PI / 2, PI / 2)), newDst);
//
//      // float intensity = intensityx < intensityy ? intensityx : intensityy;
//
//      float intensity;
//      if (f == 0) {
//        intensity = computeDistance(lightPosition, position, newDst);
//        total_phase[f] += cos(0.1 * length(lightPosition - newDst) + t * 0.5) * 100;
//      } else {
//        intensity = sqrt(pow(lightPosition.x - newDst.x, 2) + pow(lightPosition.y - newDst.y, 2));
//        total_phase[f] += cos(0.1 * length(lightPosition - newDst)) * 100;
//      }
//      // float intensity = 0.01;
//
//      vec2 result = cx_exp(vec2(0, m * 90));
//      newColor *= vec4(1.0, 0.1, 0.1, 1.0) * cx_abs(cx_mul(vec2(pow(intensity / w0, m) * exp(-pow(intensity, 2) / pow(w0, 2)), 0), result));
//      total_intensity[f] = cx_abs(cx_mul(vec2(pow(intensity / w0, m) * exp(-pow(intensity, 2) / pow(w0, 2)), 0), result));
//      total_phase[f] *= total_intensity[f];
//
//      dists[f] = abs(dst - lightPosition);
//
//      // color *= vec4(1.0, 0.1, 0.1, 1.0);
//      r = MAX_RAY_STEPS + 1;
//
//      } else if (getVoxel(newMapPos)) {
//        newColor *= vec4(0.5);
//        r = MAX_RAY_STEPS + 1;
//      }
//    }
//  }
//
//  // just define how the polarizers will look for now
//  vec2[] polarizationFirst =  {vec2(0.5, 0), vec2(0.5, 0)};
//  vec2[] polarizationSecond = {vec2(0.5, 0), vec2(0.5, 0)};
//
//  float f = 0.5;
//
//  vec2[] polFirst = {
//    cx_mul(cx_exp(cx_mul(vec2(f, 0), vec2(0, -1))), polarizationFirst[0]),
//    cx_mul(cx_exp(cx_mul(vec2(f, 0), vec2(0, -1))), polarizationFirst[1])
//  };
//
//  vec2[] polSecond = {
//    cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(f, 0))), polarizationSecond[0]),
//    cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(f, 0))), polarizationSecond[1])
//  };
//
//  // vec2 resultingPolarizationFirstX = cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(dists[0], 0))), vec2(1, 0));
//  // vec2 resultingPolarizationFirstY = cx_mul(cx_exp(cx_mul(vec2(0, 1), vec2(dists[0], 0))), vec2(1, 0));
//
//  // vec2 resultingPolarizationFirstX = cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(w0 * dists[0]))), vec2(1, 0));
//  // vec2 resultingPolarizationSecondX = cx_mul(cx_exp(cx_mul(vec2(0, 1), vec2(w0 * dists[1]))), vec2(1, 0));
//
//  // vec2 resultingPolarizationFirstY = cx_mul(cx_exp(cx_mul(vec2(0, 1), vec2(w0 * dists[0]))), vec2(1, 0));
//  // vec2 resultingPolarizationSecondY = cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(w0 * dists[1]))), vec2(1, 0));
//
//  color *= (4 * total_intensity[0] * pow(cos(abs(total_phase[0] - total_phase[1]) / 2), 2)) + (4 * total_intensity[1] * pow(cos(abs(total_phase[0] - total_phase[1]) / 2), 2));
//  // color *= (total_intensity[0] * abs(total_phase[0] + total_phase[1])) + (total_intensity[1] * abs(total_phase[1] + total_phase[0]));
//
//  // color *= abs(total_phase[0] + total_phase[1]);
//
//  // color *= total_phase[0] + total_phase[2]
//  // color *= 4 * total_intensity * pow(cos(total_phase / 2), 2);
//
//  // vec2 r = cx_exp(cx_mul(vec2(1, 0), vec2(0, -1)));
//  // if (r + 0.1 > 0.8775825618903728 && r - 0.1 < 0.8775825618903728) {
//    // color = vec4(abs(cx_mul(vec2(f, 0), vec2(0, -1))).y, 0, 0, 1);
//    // color = vec4(0.4 / cx_mul(vec2(f, 0), vec2(0, -1)).x, 0, 0, 1);
//
//    // color *= length(vec2(polFirst[0].x, polFirst[1].x));
//    // color *= float(cx_mul(cx_exp(cx_mul(vec2(0, -1), vec2(0.1, 0))), vec2(1, 0)).x);
//
//    // color *= clamp(sqrt(
//    //  pow(polFirst[0].x + polSecond[0].x, 2) +
//    //  pow(polFirst[1].x + polSecond[1].x, 2)
//    //), 0, 1);
//
//    // color *= (length(vec2(cx_add(polFirst[0], polSecond[0]).x, cx_add(polFirst[1], polSecond[1]).x)));
//    // color *= cx_modulus(cx_add(resultingPolarizationFirstX, resultingPolarizationSecondX) + cx_add(resultingPolarizationSecondX, resultingPolarizationSecondY));
//    // color *= cx_modulus(cx_add(resultingPolarizationFirstX, resultingPolarizationSecondX) + cx_add(resultingPolarizationFirstY, resultingPolarizationSecondY));
//
//      if (hits > MAX_REHITS) {
//          // endedInHit = true;
//          break;
//      };
//    }
//
//    mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
//
//    sideDist += vec3(mask) * deltaDist;
//    mapPos += ivec3(vec3(mask)) * rayStep;
//
//    d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized
//    dst = rayPos + rayDir * d; 
//
//    #ifdef BLACK_HOLE
//        vec3 newDir = blackHolePosition - dst;
//
//        float force = - -.1 / pow(length(newDir), 3);
//
//        if (dot(newDir * force, rayDir) > 0.1) {
//            color = vec4(0.);
//            break;
//        }
//
//        rayDir = normalize(rayDir + (newDir * force));
//    #endif
//
//    deltaDist = abs(vec3(length(rayDir)) / rayDir);
//    rayStep = ivec3(sign(rayDir));
//    sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
//  }
